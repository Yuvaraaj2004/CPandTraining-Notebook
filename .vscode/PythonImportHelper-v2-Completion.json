[
    {
        "label": "cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "ceil",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "ceil",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "ceil",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "floor",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "sqrt",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "ceil",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "ceil",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "ceil",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "ceil",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "floor",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "DefaultDict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "ic",
        "importPath": "icecream",
        "description": "icecream",
        "isExtraImport": true,
        "detail": "icecream",
        "documentation": {}
    },
    {
        "label": "bisect_right",
        "importPath": "bisect",
        "description": "bisect",
        "isExtraImport": true,
        "detail": "bisect",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "train_test_split",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "train_test_split",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "cross_val_score",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "StratifiedKFold",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "LeaveOneOut",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "StratifiedKFold",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "train_test_split",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "DecisionTreeClassifier",
        "importPath": "sklearn.tree",
        "description": "sklearn.tree",
        "isExtraImport": true,
        "detail": "sklearn.tree",
        "documentation": {}
    },
    {
        "label": "accuracy_score",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "precision_score",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "recall_score",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "f1_score",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "accuracy_score",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "precision_recall_fscore_support",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "confusion_matrix",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "mean_absolute_error",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "mean_squared_error",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "LogisticRegression",
        "importPath": "sklearn.linear_model",
        "description": "sklearn.linear_model",
        "isExtraImport": true,
        "detail": "sklearn.linear_model",
        "documentation": {}
    },
    {
        "label": "LinearRegression",
        "importPath": "sklearn.linear_model",
        "description": "sklearn.linear_model",
        "isExtraImport": true,
        "detail": "sklearn.linear_model",
        "documentation": {}
    },
    {
        "label": "StandardScaler",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "seaborn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "seaborn",
        "description": "seaborn",
        "detail": "seaborn",
        "documentation": {}
    },
    {
        "label": "__version__",
        "importPath": "sklearn",
        "description": "sklearn",
        "isExtraImport": true,
        "detail": "sklearn",
        "documentation": {}
    },
    {
        "label": "mkdir",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "Queue",
        "importPath": "queue",
        "description": "queue",
        "isExtraImport": true,
        "detail": "queue",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "warnings",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "warnings",
        "description": "warnings",
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "Find",
        "kind": 2,
        "importPath": "CodeForces.cfs.BinarySearch",
        "description": "CodeForces.cfs.BinarySearch",
        "peekOfCode": "def Find(q):\n    l, r = 0, n-1\n    # print(q,end=' ')\n    while l <= r:\n        mid = (l+r)//2\n        # print(l,r,arr[mid])\n        if arr[mid] == q:\n            # print(True)\n            return True\n        elif arr[mid] < q:",
        "detail": "CodeForces.cfs.BinarySearch",
        "documentation": {}
    },
    {
        "label": "arr",
        "kind": 5,
        "importPath": "CodeForces.cfs.BinarySearch",
        "description": "CodeForces.cfs.BinarySearch",
        "peekOfCode": "arr = list(map(int, input().split()))\n@cache\ndef Find(q):\n    l, r = 0, n-1\n    # print(q,end=' ')\n    while l <= r:\n        mid = (l+r)//2\n        # print(l,r,arr[mid])\n        if arr[mid] == q:\n            # print(True)",
        "detail": "CodeForces.cfs.BinarySearch",
        "documentation": {}
    },
    {
        "label": "Find",
        "kind": 2,
        "importPath": "CodeForces.cfs.LowerBound",
        "description": "CodeForces.cfs.LowerBound",
        "peekOfCode": "def Find(q):\n    l, r = 0, n-1\n    # print(q,end=' ')\n    while l <= r:\n        mid = (l+r)//2\n        # print(l,r,arr[mid])\n        if arr[mid] < q:\n            l = mid+1\n        else:\n            r = mid-1",
        "detail": "CodeForces.cfs.LowerBound",
        "documentation": {}
    },
    {
        "label": "arr",
        "kind": 5,
        "importPath": "CodeForces.cfs.LowerBound",
        "description": "CodeForces.cfs.LowerBound",
        "peekOfCode": "arr = list(map(int, input().split()))\ndef Find(q):\n    l, r = 0, n-1\n    # print(q,end=' ')\n    while l <= r:\n        mid = (l+r)//2\n        # print(l,r,arr[mid])\n        if arr[mid] < q:\n            l = mid+1\n        else:",
        "detail": "CodeForces.cfs.LowerBound",
        "documentation": {}
    },
    {
        "label": "upper",
        "kind": 2,
        "importPath": "CodeForces.cfs.range",
        "description": "CodeForces.cfs.range",
        "peekOfCode": "def upper(q):\n    l, r = 0, n-1\n    while l <= r:\n        mid = (l+r)//2\n        # print(l,r,arr[mid])\n        if arr[mid] <= q:\n            l = mid+1\n        else:\n            r = mid-1\n    # print(False,l,r)",
        "detail": "CodeForces.cfs.range",
        "documentation": {}
    },
    {
        "label": "lower",
        "kind": 2,
        "importPath": "CodeForces.cfs.range",
        "description": "CodeForces.cfs.range",
        "peekOfCode": "def lower(q):\n    l, r = 0, n-1\n    while l <= r:\n        mid = (l+r)//2\n        # print(l,r,arr[mid])\n        if arr[mid] < q:\n            l = mid+1\n        else:\n            r = mid-1\n    # print(False,l,r)",
        "detail": "CodeForces.cfs.range",
        "documentation": {}
    },
    {
        "label": "f",
        "kind": 2,
        "importPath": "CodeForces.cfs.range",
        "description": "CodeForces.cfs.range",
        "peekOfCode": "def f(x,y):\n    return upper(y)-lower(x)\nprint(*[f(*list(map(int, input().split()))) for i in range(int(input()))])",
        "detail": "CodeForces.cfs.range",
        "documentation": {}
    },
    {
        "label": "edges",
        "kind": 5,
        "importPath": "CodeForces.cfs.Shortestpath",
        "description": "CodeForces.cfs.Shortestpath",
        "peekOfCode": "edges = int(input())\nn = int(input())\nadjM = [[0]*n for i in range(n)]\nadj = [[] for i in range(n)]\nfor i in range(edges):\n    x, y, z = map(int, input().split())\n    adj[x].append((y, z))\n    adjM[x][y] = z\nfor i in adjM:\n    print(i)",
        "detail": "CodeForces.cfs.Shortestpath",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "CodeForces.cfs.Shortestpath",
        "description": "CodeForces.cfs.Shortestpath",
        "peekOfCode": "n = int(input())\nadjM = [[0]*n for i in range(n)]\nadj = [[] for i in range(n)]\nfor i in range(edges):\n    x, y, z = map(int, input().split())\n    adj[x].append((y, z))\n    adjM[x][y] = z\nfor i in adjM:\n    print(i)\nprint()",
        "detail": "CodeForces.cfs.Shortestpath",
        "documentation": {}
    },
    {
        "label": "adjM",
        "kind": 5,
        "importPath": "CodeForces.cfs.Shortestpath",
        "description": "CodeForces.cfs.Shortestpath",
        "peekOfCode": "adjM = [[0]*n for i in range(n)]\nadj = [[] for i in range(n)]\nfor i in range(edges):\n    x, y, z = map(int, input().split())\n    adj[x].append((y, z))\n    adjM[x][y] = z\nfor i in adjM:\n    print(i)\nprint()\nans = 0",
        "detail": "CodeForces.cfs.Shortestpath",
        "documentation": {}
    },
    {
        "label": "adj",
        "kind": 5,
        "importPath": "CodeForces.cfs.Shortestpath",
        "description": "CodeForces.cfs.Shortestpath",
        "peekOfCode": "adj = [[] for i in range(n)]\nfor i in range(edges):\n    x, y, z = map(int, input().split())\n    adj[x].append((y, z))\n    adjM[x][y] = z\nfor i in adjM:\n    print(i)\nprint()\nans = 0\nwhile True:",
        "detail": "CodeForces.cfs.Shortestpath",
        "documentation": {}
    },
    {
        "label": "ans",
        "kind": 5,
        "importPath": "CodeForces.cfs.Shortestpath",
        "description": "CodeForces.cfs.Shortestpath",
        "peekOfCode": "ans = 0\nwhile True:\n    visited = [False]*n\n    par = [-1]*n\n    q = [0]\n    while q:\n        node = q.pop()\n        for ind, i in enumerate(adjM[node]):\n            if not visited[ind] and i > 0:\n                par[ind] = node",
        "detail": "CodeForces.cfs.Shortestpath",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "CodeForces.cfs.SumOfDistance",
        "description": "CodeForces.cfs.SumOfDistance",
        "peekOfCode": "class Solution:\n    def sumOfDistancesInTree(self, n: int, edges: List[List[int]]) -> List[int]:\n        par=[-1 for i in range(n)]\n        ns=[1 for i in range(n)]\n        dist=[0 for i in range(n)]\n        adj=[set() for i in range(n)]\n        d=DefaultDict(dict)\n        for x,y in edges:\n            par[y]=x\n            adj[x].add(y)",
        "detail": "CodeForces.cfs.SumOfDistance",
        "documentation": {}
    },
    {
        "label": "Solution().sumOfDistancesInTree(n",
        "kind": 5,
        "importPath": "CodeForces.cfs.SumOfDistance",
        "description": "CodeForces.cfs.SumOfDistance",
        "peekOfCode": "Solution().sumOfDistancesInTree(n = 6, edges = [[0, 1],[0,2],[2,3],[2,4],[2,5]])",
        "detail": "CodeForces.cfs.SumOfDistance",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "CodeForces.Contest927.1846B",
        "description": "CodeForces.Contest927.1846B",
        "peekOfCode": "def main():\n    for i in range(int(input())):\n        l, f = [input() for i in range(3)], 0\n        for i in range(3):\n            d = defaultdict(int)\n            for j in range(3):\n                d[l[i][j]] += 1\n            # print(d)\n            if len(d) == 1:\n                if (v := list(d.items())[0][0]) != '.':",
        "detail": "CodeForces.Contest927.1846B",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "CodeForces.Contest927.1846C",
        "description": "CodeForces.Contest927.1846C",
        "peekOfCode": "def main():\n    for i in range(int(input())):\n        a, b, c = list(map(int, input().split()))\n        l = [sorted(map(int, input().split())) for i in range(a)]\n        ans = []\n        for ind, i in enumerate(l):\n            s, p, j = 0, 0, 0\n            while j < len(i) and s+i[j] <= c:\n                s += i[j]\n                p += s",
        "detail": "CodeForces.Contest927.1846C",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "CodeForces.Contest927.1846D",
        "description": "CodeForces.Contest927.1846D",
        "peekOfCode": "def main():\n    for i in range(int(input())):\n        a, b, c = list(map(int, input().split()))\n        b /= 2\n        l = [float('inf')]+sorted(map(int,\n                                      input().split()), reverse=True)\n        ans, base, m = 0, b*c, c/(b)\n        print(base, m, l)\n        for j in range(1, len(l)):\n            diff = l[j-1] - l[j]",
        "detail": "CodeForces.Contest927.1846D",
        "documentation": {}
    },
    {
        "label": "f",
        "kind": 2,
        "importPath": "CodeForces.Contest927.1846E1",
        "description": "CodeForces.Contest927.1846E1",
        "peekOfCode": "def f(n, i):\n    if n == 0:\n        return ''\n    return f(n//i, i)+str(n % i)\nl, s = [], set()\nfor i in range(2, 36):\n    x, v = f'{i-1}{i-1}', 1\n    l.append([])\n    while v < 10**6:\n        x += f\"{i-1}\"",
        "detail": "CodeForces.Contest927.1846E1",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "CodeForces.Contest927.1846E1",
        "description": "CodeForces.Contest927.1846E1",
        "peekOfCode": "def main():\n    for i in range(int(input())):\n        n = int(input())\n        # print(n, [(i, f(n, i)) for i in range(2, n)])\nif __name__ == \"__main__\":\n    main()",
        "detail": "CodeForces.Contest927.1846E1",
        "documentation": {}
    },
    {
        "label": "t",
        "kind": 5,
        "importPath": "CodeForces.Contest927.1921D",
        "description": "CodeForces.Contest927.1921D",
        "peekOfCode": "t = int(input())\nfor t in range(t):\n    ans = 0\n    a, b = map(int, input().split())\n    l1, l2 = sorted(list(map(int, input().split()))), sorted(\n        list(map(int, input().split())))\n    # print(l1, l2)\n    ai, aj, bi, bj = 0, a-1, 0, b-1\n    while ai <= aj:\n        v = [abs(l1[ai]-l2[bj]), abs(l1[aj]-l2[bi])]",
        "detail": "CodeForces.Contest927.1921D",
        "documentation": {}
    },
    {
        "label": "t",
        "kind": 5,
        "importPath": "CodeForces.Contest927.1923A",
        "description": "CodeForces.Contest927.1923A",
        "peekOfCode": "t = int(input())\nfor t in range(t):\n    n = int(input())\n    l = list(map(int, input().split()))\n    i, j = 0, n-1\n    while i < len(l) and l[i] == 0:\n        i += 1\n    while i < len(l) and l[i] == 1:\n        i += 1\n    print(sum(l[i:]))",
        "detail": "CodeForces.Contest927.1923A",
        "documentation": {}
    },
    {
        "label": "t",
        "kind": 5,
        "importPath": "CodeForces.Contest927.1923B",
        "description": "CodeForces.Contest927.1923B",
        "peekOfCode": "t = int(input())\nfor t in range(t):\n    n, k = map(int, input().split())\n    health=list(map(int,input))",
        "detail": "CodeForces.Contest927.1923B",
        "documentation": {}
    },
    {
        "label": "mask",
        "kind": 5,
        "importPath": "CodeForces.Contest927.1926D",
        "description": "CodeForces.Contest927.1926D",
        "peekOfCode": "mask = (1 << 31)-1\nfor i in range(int(input())):\n    n = int(input())\n    c = list(map(int, input().split()))\n    # print(mask)\n    ans = 0\n    s = {}\n    for j in c:\n        if s.get(mask ^ j, 0) > 0:\n            s[mask ^ j] -= 1",
        "detail": "CodeForces.Contest927.1926D",
        "documentation": {}
    },
    {
        "label": "coin",
        "kind": 2,
        "importPath": "CodeForces.Contest927.1934B",
        "description": "CodeForces.Contest927.1934B",
        "peekOfCode": "def coin(n):\n    # print(n, end=' ')\n    if n < 3:\n        return n\n    if n in v:\n        return v[n]\n    ans = n\n    for i in coins:\n        # for i in coins:\n        if i > n:",
        "detail": "CodeForces.Contest927.1934B",
        "documentation": {}
    },
    {
        "label": "d",
        "kind": 5,
        "importPath": "CodeForces.Contest927.1934B",
        "description": "CodeForces.Contest927.1934B",
        "peekOfCode": "d = {}\ncoins = [15, 10, 6, 3]\ncoins.reverse()\n# def dp(n):\n#     print(n, end=' ')\n#     if n <= 2:\n#         return n\n#     elif d.get(n, -1) != -1:\n#         return d[n]\n#     else:",
        "detail": "CodeForces.Contest927.1934B",
        "documentation": {}
    },
    {
        "label": "coins",
        "kind": 5,
        "importPath": "CodeForces.Contest927.1934B",
        "description": "CodeForces.Contest927.1934B",
        "peekOfCode": "coins = [15, 10, 6, 3]\ncoins.reverse()\n# def dp(n):\n#     print(n, end=' ')\n#     if n <= 2:\n#         return n\n#     elif d.get(n, -1) != -1:\n#         return d[n]\n#     else:\n#         ans = n",
        "detail": "CodeForces.Contest927.1934B",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "CodeForces.Contest927.1935A",
        "description": "CodeForces.Contest927.1935A",
        "peekOfCode": "def main():\n    for i in range(int(input())):\n        n = int(input())\n        s = input()\n        if s <= s[::-1]:\n            print(s if not (n & 1) else s+s[::-1])\n        else:\n            print(s[::-1] if (n & 1) else s[::-1]+s)\n            # print()\nif __name__ == \"__main__\":",
        "detail": "CodeForces.Contest927.1935A",
        "documentation": {}
    },
    {
        "label": "Solve",
        "kind": 2,
        "importPath": "CodeForces.Contest927.1941A",
        "description": "CodeForces.Contest927.1941A",
        "peekOfCode": "def Solve():\n    n, m, c = list(map(int, input().split()))\n    a, b = sorted(map(int, input().split())), sorted(map(int, input().split()))\n    ans = 0\n    for i in range(n):\n        if a[i] > c:\n            break\n        else:\n            ans += bisect_right(b, c-a[i])\n    print(ans)",
        "detail": "CodeForces.Contest927.1941A",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "CodeForces.Contest927.1941B",
        "description": "CodeForces.Contest927.1941B",
        "peekOfCode": "def main():\n    for i in range(int(input())):\n        n = int(input())\n        l = list(map(int, input().split()))\nif __name__ == \"__main__\":\n    main()",
        "detail": "CodeForces.Contest927.1941B",
        "documentation": {}
    },
    {
        "label": {
            "name": "",
            "kind": 2,
            "peekOfCode": "def  Check(mid):\n    return sum(i//mid for i in a)>=k\nl,r=1,sum(a)\nwhile r-l>1e-6:\n    mid=(l+r)/2\n    # print(l, r, mid, (v := Check(mid)))\n    if (v := Check(mid)):\n        l=mid\n    else:\n        r=mid"
        },
        "kind": 2,
        "importPath": "CodeForces.Contest927.283932B",
        "description": "CodeForces.Contest927.283932B",
        "peekOfCode": "def  Check(mid):\n    return sum(i//mid for i in a)>=k\nl,r=1,sum(a)\nwhile r-l>1e-6:\n    mid=(l+r)/2\n    # print(l, r, mid, (v := Check(mid)))\n    if (v := Check(mid)):\n        l=mid\n    else:\n        r=mid",
        "detail": "CodeForces.Contest927.283932B",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "CodeForces.Contest927.Binary_Parity",
        "description": "CodeForces.Contest927.Binary_Parity",
        "peekOfCode": "def main():\n    for i in range(int(input())):\n        n = int(input())\n        c = 0\n        while n:\n            c, n = c+n & 1, n >> 1\n        print('EVEN' if c & 1 == 0 else 'ODD')\nif __name__ == \"__main__\":\n    main()",
        "detail": "CodeForces.Contest927.Binary_Parity",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "CodeForces.Contest927.Cricket_Tournament",
        "description": "CodeForces.Contest927.Cricket_Tournament",
        "peekOfCode": "def main():\n    for i in range(int(input())):\n        a, b = list(map(int, input().split()))\n        c = 0\n        while a != 1:\n            # print(a)\n            c += a//2\n            a = (a >> 1)+(a != 1 and a & 1)\n        print('YES' if c >= b else 'NO')\nif __name__ == \"__main__\":",
        "detail": "CodeForces.Contest927.Cricket_Tournament",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "CodeForces.Contest927.Make_It_One",
        "description": "CodeForces.Contest927.Make_It_One",
        "peekOfCode": "def main():\n    for i in range(int(input())):\n        a, b = list(map(int, input().split()))\n        # d = defaultdict(set)\n        # for i in range(a, b+1):\n        #     j, v = 2, i\n        #     while j*j <= i:\n        #         if i % j == 0:\n        #             d[j].add(v)\n        #         while i % j == 0:",
        "detail": "CodeForces.Contest927.Make_It_One",
        "documentation": {}
    },
    {
        "label": "l",
        "kind": 5,
        "importPath": "CodeForces.Contest927.MCM",
        "description": "CodeForces.Contest927.MCM",
        "peekOfCode": "l = '''2\n2\n18 19\n3\n40 60 20\n'''.split('\\n')\nfor i in range(int(l.pop(0))):\n    n = int(l.pop(0))\n    mat = list(map(int, l.pop(0).split()))\n    @cache",
        "detail": "CodeForces.Contest927.MCM",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "CodeForces.Contest927.Odd_Sum",
        "description": "CodeForces.Contest927.Odd_Sum",
        "peekOfCode": "def main():\n    for i in range(int(input())):\n        n = (int(input())-2)\n        print(1+(n*(n+1)))\nif __name__ == \"__main__\":\n    main()\n# 1 3 5 2 0\n# 1\n# 1 0\n# 1 2 0",
        "detail": "CodeForces.Contest927.Odd_Sum",
        "documentation": {}
    },
    {
        "label": "t",
        "kind": 5,
        "importPath": "CodeForces.Contest927.Punched Cards",
        "description": "CodeForces.Contest927.Punched Cards",
        "peekOfCode": "t = int(input())\nfor t in range(1, t+1):\n    print(f\"Case #{t}:\")\n    a,b=map(int,input().split())\n    for i in range(2*a+1):\n        s=''\n        if i==0 or i==1:\n            s+='..'\n        s+=('+-' if i%2==0 else '|.')*(b-len(s)//2)+('+' if i%2==0 else '|')\n        print(s)",
        "detail": "CodeForces.Contest927.Punched Cards",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "CodeForces.Contest927.Swap_and_Unite",
        "description": "CodeForces.Contest927.Swap_and_Unite",
        "peekOfCode": "def main():\n    for i in range(int(input())):\n        s = input()\n        d = Counter(s)\n        ans = float('inf')\n        for i in d:\n            c, l = 0, 0\n            for ind, j in enumerate(s):\n                if j == i:\n                    c += 1",
        "detail": "CodeForces.Contest927.Swap_and_Unite",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "CodeForces.Contest927.Table_Strength",
        "description": "CodeForces.Contest927.Table_Strength",
        "peekOfCode": "def main():\n    for i in range(int(input())):\n        n = int(input())\n        l = sorted((map(int, input().split())))\n        ans, mn = 0, float('inf')\n        for j in range(n-1, -1, -1):\n            mn = min(l[j], mn)\n            ans = max(ans, mn*(n-j))\n        print(ans)\nif __name__ == \"__main__\":",
        "detail": "CodeForces.Contest927.Table_Strength",
        "documentation": {}
    },
    {
        "label": "f",
        "kind": 2,
        "importPath": "CodeForces.Round928.Vlad and a Sum of Sum of Digits",
        "description": "CodeForces.Round928.Vlad and a Sum of Sum of Digits",
        "peekOfCode": "def f(n):\n    res=0\n    while n:\n        res+=n%10\n        n//=10\n    return res\nl=[0]*((10**5)*2+1)\nfor i in range(len(l)):\n    l[i]=l[i-1]+f(i)\nfor i in range(t):",
        "detail": "CodeForces.Round928.Vlad and a Sum of Sum of Digits",
        "documentation": {}
    },
    {
        "label": "t",
        "kind": 5,
        "importPath": "CodeForces.Round928.Vlad and Division",
        "description": "CodeForces.Round928.Vlad and Division",
        "peekOfCode": "t = int(input())\nfor i in range(t):\n    n=int(input())\n    ans=0\n    l,visited=Counter(map(int,input().split())),set()\n    for i in l:\n        if i in visited:continue\n        v=i^mx\n        # print(i,v)\n        if l.get(v,0):",
        "detail": "CodeForces.Round928.Vlad and Division",
        "documentation": {}
    },
    {
        "label": "t",
        "kind": 5,
        "importPath": "CodeForces.Round928.Vlad and Shapes",
        "description": "CodeForces.Round928.Vlad and Shapes",
        "peekOfCode": "t = int(input())\nfor i in range(t):\n    n = int(input())\n    s = [Counter(input()).get('1', 0) for i in range(n)]\n    for i in range(1, n):\n        if s[i] and s[i] == s[i-1]:\n            print('SQUARE')\n            break\n        elif s[i] and s[i-1] and abs(s[i]-s[i-1]) == 2:\n            print('TRIANGLE')",
        "detail": "CodeForces.Round928.Vlad and Shapes",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "CodeForces.OMS",
        "description": "CodeForces.OMS",
        "peekOfCode": "def main():\nif __name__ == \"__main__\":\n    main()",
        "detail": "CodeForces.OMS",
        "documentation": {}
    },
    {
        "label": "y_pred",
        "kind": 5,
        "importPath": "Heart Disease Prediction with Logistic Regression.Main",
        "description": "Heart Disease Prediction with Logistic Regression.Main",
        "peekOfCode": "y_pred = model.predict(X_test)\ncm = confusion_matrix(y_test, y_pred)\nplt.figure(figsize=(8, 6))\nsns.heatmap(cm, annot=True, fmt='d', cmap='Blues', cbar=False)\nplt.xlabel('Predicted')\nplt.ylabel('True')\nplt.title('Confusion Matrix')\nplt.savefig(\"ConfusionMatrix.png\")\n# d. Report performance metrics with two decimal points\n#Fill your code here",
        "detail": "Heart Disease Prediction with Logistic Regression.Main",
        "documentation": {}
    },
    {
        "label": "cm",
        "kind": 5,
        "importPath": "Heart Disease Prediction with Logistic Regression.Main",
        "description": "Heart Disease Prediction with Logistic Regression.Main",
        "peekOfCode": "cm = confusion_matrix(y_test, y_pred)\nplt.figure(figsize=(8, 6))\nsns.heatmap(cm, annot=True, fmt='d', cmap='Blues', cbar=False)\nplt.xlabel('Predicted')\nplt.ylabel('True')\nplt.title('Confusion Matrix')\nplt.savefig(\"ConfusionMatrix.png\")\n# d. Report performance metrics with two decimal points\n#Fill your code here\nprint(f'Accuracy: {accuracy:.2f}')",
        "detail": "Heart Disease Prediction with Logistic Regression.Main",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Techdose.Arrays.3Sum",
        "description": "Techdose.Arrays.3Sum",
        "peekOfCode": "class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        nums.sort()\n        s = set()\n        for i in range(len(nums)):\n            j, k = i+1, len(nums)-1\n            while j < k:\n                if nums[i]+nums[j]+nums[k] > 0:\n                    k -= 1\n                elif nums[i]+nums[j]+nums[k] < 0:",
        "detail": "Techdose.Arrays.3Sum",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Techdose.Arrays.4Sum II",
        "description": "Techdose.Arrays.4Sum II",
        "peekOfCode": "class Solution:\n    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\n        s = {}\n        for i in nums1:\n            for j in nums2:\n                s[i+j] = s.get(i+j, 0)+1\n        ans = 0\n        for i in nums3:\n            for j in nums4:\n                if s.get(-i-j, None):",
        "detail": "Techdose.Arrays.4Sum II",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Techdose.Arrays.4Sum",
        "description": "Techdose.Arrays.4Sum",
        "peekOfCode": "class Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        nums.sort()\n        ans = set()\n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                l, r = j+1, len(nums)-1\n                while l < r:\n                    if nums[l]+nums[r]+nums[i]+nums[j] < target:\n                        l += 1",
        "detail": "Techdose.Arrays.4Sum",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Techdose.Arrays.Best Time to Buy and Sell Stock",
        "description": "Techdose.Arrays.Best Time to Buy and Sell Stock",
        "peekOfCode": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        ma = 0\n        mx = 0\n        # if prices==sorted(prices)[::-1]:return 0\n        for i in range(len(prices)-1, -1, -1):\n            if prices[i] > ma:\n                ma = prices[i]\n            else:\n                mx = max(mx, ma-prices[i])",
        "detail": "Techdose.Arrays.Best Time to Buy and Sell Stock",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Techdose.Arrays.Capacity To Ship Packages Within D Days",
        "description": "Techdose.Arrays.Capacity To Ship Packages Within D Days",
        "peekOfCode": "class Solution:\n    def shipWithinDays(self, weights: List[int], days: int) -> int:\n        low, high = max(weights), sum(weights)\n        def check(mid):\n            d, w = 1, 0\n            for i in weights:\n                if w+i > mid:\n                    w = i\n                    d += 1\n                else:",
        "detail": "Techdose.Arrays.Capacity To Ship Packages Within D Days",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Techdose.Arrays.Count of Smaller Numbers After Self",
        "description": "Techdose.Arrays.Count of Smaller Numbers After Self",
        "peekOfCode": "class Solution:\n    def countSmaller(self, nums: List[int]) -> List[int]:\n        nums = [(nums[i], i) for i in range(len(nums)-1, -1, -1)]\n        res = [0]*len(nums)\n        def Merge(l=0, r=len(nums)-1):\n            if l >= r:\n                return\n            m = (l+r)//2\n            Merge(l, m)\n            Merge(m+1, r)",
        "detail": "Techdose.Arrays.Count of Smaller Numbers After Self",
        "documentation": {}
    },
    {
        "label": "MedianFinder",
        "kind": 6,
        "importPath": "Techdose.Arrays.Find Median from Data Stream",
        "description": "Techdose.Arrays.Find Median from Data Stream",
        "peekOfCode": "class MedianFinder:\n    def __init__(self):\n        from sortedcontainers import SortedList\n        self.c = 0\n        self.prefix = SortedList()\n    def addNum(self, num: int) -> None:\n        self.prefix.add(num)\n        self.c += 1\n    def findMedian(self) -> float:\n        if len(self.prefix) % 2:",
        "detail": "Techdose.Arrays.Find Median from Data Stream",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Techdose.Arrays.Kth Largest Element in an Array",
        "description": "Techdose.Arrays.Kth Largest Element in an Array",
        "peekOfCode": "class Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        def quickSelect(arr, l, r, e):\n            if l > r:\n                return -1\n            pivot, i, j = r, l, r\n            while i < j:\n                while i < len(arr) and arr[pivot] > arr[i]:\n                    i += 1\n                while j >= 0 and arr[pivot] <= arr[j]:",
        "detail": "Techdose.Arrays.Kth Largest Element in an Array",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Techdose.Arrays.Largest sum contiguous subarray",
        "description": "Techdose.Arrays.Largest sum contiguous subarray",
        "peekOfCode": "class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        if max(nums) < 0:\n            return max(nums)\n        s, m = 0, 0\n        for i in nums:\n            if s+i < 0:\n                s = 0\n            else:\n                s += i",
        "detail": "Techdose.Arrays.Largest sum contiguous subarray",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Techdose.Arrays.Merge Intervals",
        "description": "Techdose.Arrays.Merge Intervals",
        "peekOfCode": "class Solution:\n    def merge(self, inter: List[List[int]]) -> List[List[int]]:\n        inter.sort()\n        print(inter)\n        def dp(ind=0, end=-1):\n            # print(ind,end)\n            if ind == len(inter):\n                return -float('inf')\n            elif end != -1 and end < inter[ind][0]:\n                return -float('inf')",
        "detail": "Techdose.Arrays.Merge Intervals",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Techdose.Arrays.Minimum Size Subarray Sum",
        "description": "Techdose.Arrays.Minimum Size Subarray Sum",
        "peekOfCode": "class Solution:\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\n        left, s, ans = 0, 0, float('inf')\n        for i in range(len(nums)):\n            s += nums[i]\n            while s > target:\n                s -= nums[left]\n                ans = min(ans, i-left+1)\n                left += 1\n            if s >= target:",
        "detail": "Techdose.Arrays.Minimum Size Subarray Sum",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Techdose.Arrays.Next Permutation",
        "description": "Techdose.Arrays.Next Permutation",
        "peekOfCode": "class Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        lastpeak = -1\n        for i in range(1, len(nums)):\n            if nums[i] > nums[i-1]:\n                lastpeak = i\n        if lastpeak == -1:",
        "detail": "Techdose.Arrays.Next Permutation",
        "documentation": {}
    },
    {
        "label": "NumArray",
        "kind": 6,
        "importPath": "Techdose.Arrays.Range Sum Query - Immutable",
        "description": "Techdose.Arrays.Range Sum Query - Immutable",
        "peekOfCode": "class NumArray:\n    def __init__(self, nums: List[int]):\n        self.array = [nums[0]]\n        for i in range(1, len(nums)):\n            self.array.append(self.array[-1]+nums[i])\n        print(self.array)\n    def sumRange(self, left: int, right: int) -> int:\n        return self.array[right]-(self.array[left-1] if left-1 >= 0 else 0)\n# Your NumArray object will be instantiated and called as such:\n# obj = NumArray(nums)",
        "detail": "Techdose.Arrays.Range Sum Query - Immutable",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Techdose.Arrays.Search in Rotated Sorted Array",
        "description": "Techdose.Arrays.Search in Rotated Sorted Array",
        "peekOfCode": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        # return True if target in nums else False\n        for i in range(len(nums)-1):\n            if nums[i]>nums[i+1]:",
        "detail": "Techdose.Arrays.Search in Rotated Sorted Array",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Techdose.Arrays.Sort Colors",
        "description": "Techdose.Arrays.Sort Colors",
        "peekOfCode": "class Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        l = [0]*3\n        for i in nums:\n            l[i] += 1\n        for i in range(1, 3):\n            l[i] += l[i-1]",
        "detail": "Techdose.Arrays.Sort Colors",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Techdose.Arrays.Trapping Rain Water",
        "description": "Techdose.Arrays.Trapping Rain Water",
        "peekOfCode": "class Solution:\n    def trap(self, height: List[int]) -> int:\n        l, r = 0, len(height)-1\n        lmax, rmax = height[l], height[r]\n        c = 0\n        for i in range(1, len(height)):\n            if lmax < rmax:\n                l += 1\n                if lmax-height[l] < 0:\n                    lmax = max(height[l], lmax)",
        "detail": "Techdose.Arrays.Trapping Rain Water",
        "documentation": {}
    },
    {
        "label": "Solutio",
        "kind": 6,
        "importPath": "Techdose.Arrays.Two Sum",
        "description": "Techdose.Arrays.Two Sum",
        "peekOfCode": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        HashMap<Integer,Integer> map=new HashMap<Integer,Integer>();\n        for(int i=0;i<nums.length;i++){\n            if(map.containsKey(target-nums[i])) return new int[]{map.get(target-nums[i]),i};\n            map.put(nums[i],i);\n        }\n    return new int[]{0,0};\n    }\n}",
        "detail": "Techdose.Arrays.Two Sum",
        "documentation": {}
    },
    {
        "label": "f",
        "kind": 2,
        "importPath": "Techdose.BackTracking.N-Queens",
        "description": "Techdose.BackTracking.N-Queens",
        "peekOfCode": "def f(n):\n    q=[['.']*n for i in range(n)]\n    ans=[0]\n    def Cutting(ind,pos):\n        ind=ind-1\n        l,r=pos-1,pos+1\n        while ind>=0:\n            if l>=0 and q[ind][l]=='Q':return False\n            if  r<n and q[ind][r]=='Q':return False\n            l-=1;r+=1;ind-=1",
        "detail": "Techdose.BackTracking.N-Queens",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Techdose.BitManipulation.Bitwise AND of Numbers Range",
        "description": "Techdose.BitManipulation.Bitwise AND of Numbers Range",
        "peekOfCode": "class Solution:\n    def rangeBitwiseAnd(self, left: int, right: int) -> int:\n        while right > left:\n            right = right & (right-1)\n        return right",
        "detail": "Techdose.BitManipulation.Bitwise AND of Numbers Range",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Techdose.BitManipulation.Counting Bits",
        "description": "Techdose.BitManipulation.Counting Bits",
        "peekOfCode": "class Solution:\n    def countBits(self, n: int) -> List[int]:\n        if n == 0:\n            return [0]\n        elif n == 1:\n            return [0, 1]\n        dp = [-1]*(n+1)\n        dp[0], dp[1] = 0, 1\n        for i in range(2, n+1):\n            dp[i] = (dp[i >> 1]+(i & 1) if i & (i-1) else 1)",
        "detail": "Techdose.BitManipulation.Counting Bits",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Techdose.BitManipulation.DecodeXORedPermutation",
        "description": "Techdose.BitManipulation.DecodeXORedPermutation",
        "peekOfCode": "class Solution:\n    def decode(self, encoded: List[int]) -> List[int]:\n        a, res = 0, []\n        for i in range(len(encoded)+2):\n            a ^= i\n            if i < len(encoded)+1 and i % 2 == 1:\n                a ^= encoded[i]\n        res.append(a)\n        for i in range(len(encoded)):\n            res.append(res[-1] ^ encoded[i])",
        "detail": "Techdose.BitManipulation.DecodeXORedPermutation",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Techdose.BitManipulation.HammingDistance",
        "description": "Techdose.BitManipulation.HammingDistance",
        "peekOfCode": "class Solution:\n    def hammingDistance(self, x: int, y: int) -> int:\n        def countbits(n):\n            s = 0\n            while n > 0:\n                if n & 1:\n                    s += 1\n                n >>= 1\n            return s\n        return countbits(x ^ y)",
        "detail": "Techdose.BitManipulation.HammingDistance",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Techdose.BitManipulation.Majority",
        "description": "Techdose.BitManipulation.Majority",
        "peekOfCode": "class Solution:\n    def majorityElement(self, nums: List[int]) -> int:\n        def BoyerMoore():\n            ele, vot = -1, 0\n            for i in nums:\n                if vot == 0:\n                    ele = i\n                    vot += 1\n                else:\n                    if i == ele:",
        "detail": "Techdose.BitManipulation.Majority",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Techdose.BitManipulation.SingleNumber1",
        "description": "Techdose.BitManipulation.SingleNumber1",
        "peekOfCode": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n          s = nums[0]\n           for i in range(1, len(nums)):\n                s ^= nums[i]\n            return s",
        "detail": "Techdose.BitManipulation.SingleNumber1",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Techdose.BitManipulation.singleNumber2",
        "description": "Techdose.BitManipulation.singleNumber2",
        "peekOfCode": "class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        s1, s2 = set(), set()\n        for i in nums:\n            if i not in s1:\n                s1.add(i)\n            elif i not in s2:\n                s2.add(i)\n            else:\n                s1.discard(i)",
        "detail": "Techdose.BitManipulation.singleNumber2",
        "documentation": {}
    },
    {
        "label": "f",
        "kind": 2,
        "importPath": "Techdose.CSES.permutations",
        "description": "Techdose.CSES.permutations",
        "peekOfCode": "def f(n):\n    if n == 1:\n        print(1)\n    elif n in {2, 3}:\n        print('No Solution'.upper())\n    elif n==4:\n        print(*[ce])\n    else:\n        ans = []\n        c1, c2 = 1, n//2+1+(n & 1)",
        "detail": "Techdose.CSES.permutations",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "Techdose.CSES.WeirdAlgorithm",
        "description": "Techdose.CSES.WeirdAlgorithm",
        "peekOfCode": "n = int(input())\nwhile n != 1:\n    print(n, end=' ')\n    if n & 1:\n        n = n*3+1\n    else:\n        n //= 2\nprint(n, end=' ')",
        "detail": "Techdose.CSES.WeirdAlgorithm",
        "documentation": {}
    },
    {
        "label": "MyHashMap",
        "kind": 6,
        "importPath": "Techdose.HashMap.Design HashMap",
        "description": "Techdose.HashMap.Design HashMap",
        "peekOfCode": "class MyHashMap:\n    def __init__(self):\n        self.d = {}\n    def put(self, key: int, value: int) -> None:\n        self.d[key] = value\n    def get(self, key: int) -> int:\n        return self.d[key] if key in self.d else -1\n    def remove(self, key: int) -> None:\n        if key in self.d:\n            del self.d[key]",
        "detail": "Techdose.HashMap.Design HashMap",
        "documentation": {}
    },
    {
        "label": "Solutio",
        "kind": 6,
        "importPath": "Techdose.HashMap.Group Anagrams",
        "description": "Techdose.HashMap.Group Anagrams",
        "peekOfCode": "class Solution\n{\n    public List<List<String>> groupAnagrams(String[] strs)\n    {\n      Map<String, List<String>> map = new HashMap<>();\n        for(String s : strs)\n\t\t{\n            char[] ca = s.toCharArray();\n            Arrays.sort(ca);\n            String keyStr = String.valueOf(ca);",
        "detail": "Techdose.HashMap.Group Anagrams",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Techdose.HashMap.Maximal Rectangle",
        "description": "Techdose.HashMap.Maximal Rectangle",
        "peekOfCode": "class Solution:\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\n        def getVal(ind, left, right):\n            return (len(matrix[0]) if right == -1 else right)-(0 if left == -1 else left+1)\n        left, right = [0]*len(matrix[0]), [0]*len(matrix[0])\n        ans, stack = 0, []\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if matrix[i][j] == '1':\n                    matrix[i][j] = 1+(matrix[i-1][j] if i else 0)",
        "detail": "Techdose.HashMap.Maximal Rectangle",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Techdose.HashMap.Top K Frequent Elements",
        "description": "Techdose.HashMap.Top K Frequent Elements",
        "peekOfCode": "class Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        heap = {}\n        for i in nums:\n            heap[i] = heap.get(i, 0)-1\n        heap = [i[::-1] for i in heap.items()]\n        heapify(heap)\n        return [heappop(heap)[1] for i in range(k)]",
        "detail": "Techdose.HashMap.Top K Frequent Elements",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Techdose.HashMap.Valid Sudoku",
        "description": "Techdose.HashMap.Valid Sudoku",
        "peekOfCode": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        trans = [[board[j][i]\n                  for j in range(len(board[i]))] for i in range(len(board))]\n        for i in trans:\n            if len(set(i))-1 != sum([1 for j in i if (j != '.')]):\n                # print(i,len(set(i)),sum([1 for j in i if(j!='.')]))\n                return False\n        for i in board:\n            if len(set(i))-1 != sum([1 for j in i if (j != '.')]):",
        "detail": "Techdose.HashMap.Valid Sudoku",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Techdose.LinkedList.Add 2 linkedLists represented as numbers",
        "description": "Techdose.LinkedList.Add 2 linkedLists represented as numbers",
        "peekOfCode": "class Solution:\n    def addTwoNumbers(self, lis1: Optional[ListNode], lis2: Optional[ListNode]) -> Optional[ListNode]:\n        def String(node):\n            if node:\n                if node.next:\n                    return String(node.next)+str(node.val)\n                else:\n                    return str(node.val)\n        root = ListNode()\n        temp = root",
        "detail": "Techdose.LinkedList.Add 2 linkedLists represented as numbers",
        "documentation": {}
    },
    {
        "label": "f",
        "kind": 5,
        "importPath": "Techdose.LinkedList.Createfile",
        "description": "Techdose.LinkedList.Createfile",
        "peekOfCode": "f = '''Reverse a linkedList (Iterative and recursive)\nLoop detection in LinkedList\nFind intersection node or starting node of a loop in linkedList\nRemove Duplicates in LinkedList\nAdd 2 linkedLists represented as numbers\nFlatten a linkedList\nMultiply 2 nos represented as LinkedList'''.split('\\n')\nfor i in f:\n    open(f'v:\\IpyNotebook\\Techdose\\LinkedList\\\\{i}.py', 'w')",
        "detail": "Techdose.LinkedList.Createfile",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Techdose.LinkedList.Find intersection node or starting node of a loop in linkedList",
        "description": "Techdose.LinkedList.Find intersection node or starting node of a loop in linkedList",
        "peekOfCode": "class Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        if not head:\n            return False\n        slow = fast = head\n        fast = fast.next\n        while fast:\n            if fast == slow:\n                return True\n            fast = fast.next",
        "detail": "Techdose.LinkedList.Find intersection node or starting node of a loop in linkedList",
        "documentation": {}
    },
    {
        "label": "NestedIterator",
        "kind": 6,
        "importPath": "Techdose.LinkedList.Flatten a linkedList",
        "description": "Techdose.LinkedList.Flatten a linkedList",
        "peekOfCode": "class NestedIterator:\n    def __init__(self, nestedList: [NestedInteger]):\n        v = []\n        def dfs(l=nestedList):\n            if l.isInteger():\n                v.append(l.getInteger())\n            else:\n                for i in l.getList():\n                    dfs(i)\n        for i in nestedList:",
        "detail": "Techdose.LinkedList.Flatten a linkedList",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Techdose.LinkedList.Loop detection in LinkedList",
        "description": "Techdose.LinkedList.Loop detection in LinkedList",
        "peekOfCode": "class Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        if not head:\n            return False\n        slow = fast = head\n        fast = fast.next\n        while fast:\n            if fast == slow:\n                return True\n            fast = fast.next",
        "detail": "Techdose.LinkedList.Loop detection in LinkedList",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Techdose.LinkedList.Multiply 2 nos represented as LinkedList",
        "description": "Techdose.LinkedList.Multiply 2 nos represented as LinkedList",
        "peekOfCode": "class Solution:\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        def rec(node=head):\n            if not node:\n                return 0\n            else:\n                c = node.val*2//10\n                node.val = (node.val*2 if node.val*2 <\n                            10 else node.val*2 % 10)+rec(node.next)\n                return c",
        "detail": "Techdose.LinkedList.Multiply 2 nos represented as LinkedList",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Techdose.LinkedList.Remove Duplicates in LinkedList",
        "description": "Techdose.LinkedList.Remove Duplicates in LinkedList",
        "peekOfCode": "class Solution:\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        def remove(root):\n            while (root != None):\n                temp = root.next\n                while (temp != None and temp.val == root.val):\n                    temp = temp.next\n                root.next = temp\n                root = root.next\n        remove(head)",
        "detail": "Techdose.LinkedList.Remove Duplicates in LinkedList",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Techdose.LinkedList.Reverse a linkedList (Iterative and recursive)",
        "description": "Techdose.LinkedList.Reverse a linkedList (Iterative and recursive)",
        "peekOfCode": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        pre = None\n        temp = head\n        while (temp != None):\n            nxt = temp.next\n            temp.next = pre\n            pre = temp\n            temp = nxt\n        return pre",
        "detail": "Techdose.LinkedList.Reverse a linkedList (Iterative and recursive)",
        "documentation": {}
    },
    {
        "label": "combination",
        "kind": 2,
        "importPath": "Techdose.Math.Calculate NCR value for given N and R",
        "description": "Techdose.Math.Calculate NCR value for given N and R",
        "peekOfCode": "def combination(n, r, memo=dict()):\n            if r == 0 or n == r:\n                return 1\n            elif n == r-1 or r == 1:\n                return n\n            elif (n, r) in memo.keys():\n                return memo[(n, r)]\n            else:\n                memo[(n, r)] = combination(n-1, r-1)+combination(n-1, r)\n                return memo[(n, r)]",
        "detail": "Techdose.Math.Calculate NCR value for given N and R",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Techdose.Math.Count Primes",
        "description": "Techdose.Math.Count Primes",
        "peekOfCode": "class Solution:\n    def countPrimes(self, n: int) -> int:\n        c, v = 0, sqrt(n)+1\n        s = set()\n        for i in range(2, n):\n            if i not in s:\n                c += 1\n                if i < v:\n                    for j in range(i**2, n, i):\n                        s.add(j)",
        "detail": "Techdose.Math.Count Primes",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Techdose.Math.Pow(x. n)",
        "description": "Techdose.Math.Pow(x. n)",
        "peekOfCode": "class Solution:\n    def myPow(self, x: float, n: int) -> float:\n        def Pow(b=x, p=n):\n            if p == 0:\n                return 1\n            return (b if p & 1 else 1)*Pow(b*b, p >> 1)\n        return 1 if n ==0 else (Pow() if n>0 else 1/Pow(x,-n))",
        "detail": "Techdose.Math.Pow(x. n)",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Techdose.Math.Unique Binary Search Trees",
        "description": "Techdose.Math.Unique Binary Search Trees",
        "peekOfCode": "class Solution:\n    def numTrees(self, n: int) -> int:\n        def combination(n, r, memo=dict()):\n            if r == 0 or n == r:\n                return 1\n            elif n == r-1 or r == 1:\n                return n\n            elif (n, r) in memo.keys():\n                return memo[(n, r)]\n            else:",
        "detail": "Techdose.Math.Unique Binary Search Trees",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Techdose.Matrix.Kth Smallest Number in Multiplication Table",
        "description": "Techdose.Matrix.Kth Smallest Number in Multiplication Table",
        "peekOfCode": "class Solution:\n    def findKthNumber(self, m: int, n: int, k: int) -> int:\n        mn, mx = 1, m*n\n        while mn <= mx:\n            mid = (mn+mx)//2\n            if sum([min(n, mid//i) for i in range(1, m+1)]) >= k:\n                ans = mid\n                mx = mid-1\n            else:\n                mn = mid+1",
        "detail": "Techdose.Matrix.Kth Smallest Number in Multiplication Table",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Techdose.Matrix.Median in row-wise sorted matrix",
        "description": "Techdose.Matrix.Median in row-wise sorted matrix",
        "peekOfCode": "class Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        for i in range(len(matrix)):\n            for j in range(i, len(matrix[i])):\n                t = matrix[j][i]\n                matrix[j][i] = matrix[i][j]\n                matrix[i][j] = t",
        "detail": "Techdose.Matrix.Median in row-wise sorted matrix",
        "documentation": {}
    },
    {
        "label": "merge",
        "kind": 2,
        "importPath": "Techdose.Sorting.sorting",
        "description": "Techdose.Sorting.sorting",
        "peekOfCode": "def merge(l):\n    def Divide(arr, l, r):\n        if l >= r:\n            return\n        else:\n            m = l+(r-l)//2\n            Divide(arr, l, m)\n            Divide(arr, m+1, r)\n            Merge(arr, l, m, r)\n    def Merge(arr, l, m, r):",
        "detail": "Techdose.Sorting.sorting",
        "documentation": {}
    },
    {
        "label": "bubble",
        "kind": 2,
        "importPath": "Techdose.Sorting.sorting",
        "description": "Techdose.Sorting.sorting",
        "peekOfCode": "def bubble(l):\n    for i in range(len(l)):\n        swap = False\n        for j in range(len(l)-i-1):\n            if l[j] > l[j+1]:\n                swap = True\n                l[j], l[j+1] = l[j+1], l[j]\n        if not swap:\n            break\n    print(l)",
        "detail": "Techdose.Sorting.sorting",
        "documentation": {}
    },
    {
        "label": "selection",
        "kind": 2,
        "importPath": "Techdose.Sorting.sorting",
        "description": "Techdose.Sorting.sorting",
        "peekOfCode": "def selection(l):\n    for i in range(len(l)):\n        maxi = i\n        for j in range(i+1, len(l)):\n            if l[maxi] > l[j]:\n                maxi = j\n        l[i], l[maxi] = l[maxi], l[i]\n    print(l)\ndef insertion(l):\n    for i in range(len(l)):",
        "detail": "Techdose.Sorting.sorting",
        "documentation": {}
    },
    {
        "label": "insertion",
        "kind": 2,
        "importPath": "Techdose.Sorting.sorting",
        "description": "Techdose.Sorting.sorting",
        "peekOfCode": "def insertion(l):\n    for i in range(len(l)):\n        for j in range(i, 0, -1):\n            if l[j] < l[j-1]:\n                l[j], l[j-1] = l[j-1], l[j]\n    print(l)\ndef QuicSort(arr):\n    def Sort(low=0, high=len(arr)-1):\n        pivot, l, r = 0, low, high\n        while l < r:",
        "detail": "Techdose.Sorting.sorting",
        "documentation": {}
    },
    {
        "label": "QuicSort",
        "kind": 2,
        "importPath": "Techdose.Sorting.sorting",
        "description": "Techdose.Sorting.sorting",
        "peekOfCode": "def QuicSort(arr):\n    def Sort(low=0, high=len(arr)-1):\n        pivot, l, r = 0, low, high\n        while l < r:\n            while l < len(arr) and arr[l] > arr[pivot]:\n                l += 1\n            while r > -1 and arr[r] <= arr[pivot]:\n                r -= 1\n            if l < r:\n                arr[l], arr[r] = arr[r], arr[l]",
        "detail": "Techdose.Sorting.sorting",
        "documentation": {}
    },
    {
        "label": "radix",
        "kind": 2,
        "importPath": "Techdose.Sorting.sorting",
        "description": "Techdose.Sorting.sorting",
        "peekOfCode": "def radix(nums, b=12):\n    mx = max(nums)\n    k = 1\n    while mx//k:\n        l = [0 for i in range(b)]\n        for i in range(len(nums)):\n            l[nums[i]//k % b] += 1\n        for i in range(1, b):\n            l[i] += l[i-1]\n        arr = [0]*len(nums)",
        "detail": "Techdose.Sorting.sorting",
        "documentation": {}
    },
    {
        "label": "quickSelect",
        "kind": 2,
        "importPath": "Techdose.Sorting.sorting",
        "description": "Techdose.Sorting.sorting",
        "peekOfCode": "def quickSelect(arr, l, r, e, c=0):\n    if l > r or e > len(arr):\n        return -1\n    pivot, i, j = r, l, r\n    while i < j:\n        while i < len(arr) and arr[pivot] > arr[i]:\n            i += 1\n        while j >= 0 and arr[pivot] <= arr[j]:\n            j -= 1\n        if i < j:",
        "detail": "Techdose.Sorting.sorting",
        "documentation": {}
    },
    {
        "label": "arr",
        "kind": 5,
        "importPath": "Techdose.Sorting.sorting",
        "description": "Techdose.Sorting.sorting",
        "peekOfCode": "arr = [170, 45, 75, 90, 802, 24, 2, 66]\n# QuicSort(arr)\n# print(radix(arr[::]))\nprint(quickSelect(arr, 0, len(arr)-1, 10))\nfor i in range(0, len(arr)):\n    quickSelect(arr[::], 0, len(arr)-1, i)\nprint(arr)",
        "detail": "Techdose.Sorting.sorting",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Techdose.Stack and queue.Basic Calculator II",
        "description": "Techdose.Stack and queue.Basic Calculator II",
        "peekOfCode": "class Solution:\n    def calculate(self, s: str) -> int:\n        def postFix():\n            stack, i = [], 0\n            exp = []\n            while i < len(s):\n                if s[i] == ' ':\n                    i += 1\n                elif s[i] == '+' or s[i] == '-':\n                    while stack:",
        "detail": "Techdose.Stack and queue.Basic Calculator II",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Techdose.Stack and queue.Basic Calculator",
        "description": "Techdose.Stack and queue.Basic Calculator",
        "peekOfCode": "class Solution:\n    def calculate(self, s: str) -> int:\n        def postfix(s):\n            print(s)\n            stack, i = [], 0\n            ans = []\n            while i < len(s):\n                if s[i] == '(':\n                    stack.append('(')\n                    i += 1",
        "detail": "Techdose.Stack and queue.Basic Calculator",
        "documentation": {}
    },
    {
        "label": "MyQueue",
        "kind": 6,
        "importPath": "Techdose.Stack and queue.Implement Queue using Stacks",
        "description": "Techdose.Stack and queue.Implement Queue using Stacks",
        "peekOfCode": "class MyQueue:\n    def __init__(self):\n        self.stack = []\n        self.queue = []\n    def push(self, x: int) -> None:\n        print(self.queue, self.stack)\n        self.stack.append(x)\n    def pop(self) -> int:\n        print(self.queue, self.stack)\n        self.queue = [self.stack.pop()",
        "detail": "Techdose.Stack and queue.Implement Queue using Stacks",
        "documentation": {}
    },
    {
        "label": "MyQueue",
        "kind": 6,
        "importPath": "Techdose.Stack and queue.Implement Stack using Queues",
        "description": "Techdose.Stack and queue.Implement Stack using Queues",
        "peekOfCode": "class MyQueue:\n    def __init__(self):\n        self.stack = []\n        self.queue = []\n    def push(self, x: int) -> None:\n        print(self.queue, self.stack)\n        self.stack.append(x)\n    def pop(self) -> int:\n        print(self.queue, self.stack)\n        self.queue = [self.stack.pop()",
        "detail": "Techdose.Stack and queue.Implement Stack using Queues",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Techdose.Stack and queue.Largest Rectangle in Histogram",
        "description": "Techdose.Stack and queue.Largest Rectangle in Histogram",
        "peekOfCode": "class Solution:\n    def largestRectangleArea(self, height: List[int]) -> int:\n        def Form(l, r, c):\n            arr, stack = [], []\n            for i in range(l, r, c):\n                if not stack:\n                    stack.append(i)\n                    arr.append(-1)\n                else:\n                    while stack and height[stack[-1]] >= height[i]:",
        "detail": "Techdose.Stack and queue.Largest Rectangle in Histogram",
        "documentation": {}
    },
    {
        "label": "LRUCache",
        "kind": 6,
        "importPath": "Techdose.Stack and queue.LRU Cache",
        "description": "Techdose.Stack and queue.LRU Cache",
        "peekOfCode": "class LRUCache:\n    def __init__(self, capacity: int):\n        self.d = OrderedDict()\n        self.cap = capacity\n    def get(self, key: int) -> int:\n        if key in self.d:\n            self.d.move_to_end(key)\n            return self.d[key]\n        return -1\n    def put(self, key: int, value: int) -> None:",
        "detail": "Techdose.Stack and queue.LRU Cache",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Techdose.Stack and queue.Next Greater Element I",
        "description": "Techdose.Stack and queue.Next Greater Element I",
        "peekOfCode": "class Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        d, stack = {}, []\n        for i in range(len(nums2)-1, -1, -1):\n            while stack and stack[-1] < nums2[i]:\n                stack.pop()\n            d[nums2[i]] = -1 if not stack else stack[-1]\n            stack.append(nums2[i])\n        for i in range(len(nums1)):\n            nums1[i] = d[nums1[i]]",
        "detail": "Techdose.Stack and queue.Next Greater Element I",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Techdose.Stack and queue.Rotting Oranges",
        "description": "Techdose.Stack and queue.Rotting Oranges",
        "peekOfCode": "class Solution:\n    def orangesRotting(self, grid: List[List[int]]) -> int:\n        rotten = []\n        check = [[-1, 0], [1, 0], [0, 1], [0, -1]]\n        def valid(i, j):\n            if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0 or grid[i][j] == 2:\n                return False\n            return True\n        c = [0]\n        def bfs(n):",
        "detail": "Techdose.Stack and queue.Rotting Oranges",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "Techdose.Stack and queue.Valid Parentheses",
        "description": "Techdose.Stack and queue.Valid Parentheses",
        "peekOfCode": "class Solution:\n    def isValid(self, s: str) -> bool:\n        if (len(s) % 2 or s[0] in [')', '}', ']']):\n            return False\n        l = []\n        for i in s:\n            if i in ['[', '{', '(']:\n                l.append(i)\n            elif i == ']' and len(l) > 0 and l[-1] == '[':\n                l.pop(-1)",
        "detail": "Techdose.Stack and queue.Valid Parentheses",
        "documentation": {}
    },
    {
        "label": "files",
        "kind": 5,
        "importPath": "Techdose.Fold",
        "description": "Techdose.Fold",
        "peekOfCode": "files = ['''Implement Trie (Prefix Tree)\nImplement Trie II (Prefix Tree)\nDesign Add and Search Words Data Structure\nCount number of strings with given prefix\nMaximum XOR of 2 numbers in an array\nWord Break\nWord Break II'''.split('\\n'), '''\nCourse Schedule II\nCourse Schedule\nEvaluate Division",
        "detail": "Techdose.Fold",
        "documentation": {}
    },
    {
        "label": "HashMap",
        "kind": 6,
        "importPath": "Training.HashMap",
        "description": "Training.HashMap",
        "peekOfCode": "class HashMap:\n    def __init__(self,size,mod=15):\n        self.size=size\n        self.l=[None for i in range(size)]\n        self.mod=mod\n    def add(self,value):\n        ind=value%self.mod\n        while self.l[ind]!=None:\n            ind+=1\n        self.l[ind]=value",
        "detail": "Training.HashMap",
        "documentation": {}
    },
    {
        "label": "Stack",
        "kind": 6,
        "importPath": "Training.StackImplement",
        "description": "Training.StackImplement",
        "peekOfCode": "class Stack:\n    def __init__(self, size=float('inf')) -> None:\n        self.l = []\n        self.size = 0\n        self.limit = size\n    def pop(self):\n        if self.IsEmpty():\n            print(\"UnderFlow\")\n        self.size -= 1\n        return self.l.pop()",
        "detail": "Training.StackImplement",
        "documentation": {}
    },
    {
        "label": "queue",
        "kind": 6,
        "importPath": "Training.StackImplement",
        "description": "Training.StackImplement",
        "peekOfCode": "class queue:\n    def __init__(self, size=float('inf')) -> None:\n        self.l = []\n        self.size = 0\n        self.limit = size\n    def dequeue(self):\n        if self.IsEmpty():\n            print(\"UnderFlow\")\n        self.size -= 1\n        return self.l.pop(0)",
        "detail": "Training.StackImplement",
        "documentation": {}
    },
    {
        "label": "deque",
        "kind": 6,
        "importPath": "Training.StackImplement",
        "description": "Training.StackImplement",
        "peekOfCode": "class deque(queue):\n    def popleft(self):\n        if super().IsEmpty():\n            print(\"UnderFlow\")\n        self.size -= 1\n        return self.l.pop()\nq = deque(size=10)\nfor i in range(11):\n    q.enqueue(random.random())\n    print(q)",
        "detail": "Training.StackImplement",
        "documentation": {}
    },
    {
        "label": "q",
        "kind": 5,
        "importPath": "Training.StackImplement",
        "description": "Training.StackImplement",
        "peekOfCode": "q = deque(size=10)\nfor i in range(11):\n    q.enqueue(random.random())\n    print(q)\nprint([q.popleft() for i in range(5)])",
        "detail": "Training.StackImplement",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "Univariate Data Analysis and Visualization.Main",
        "description": "Univariate Data Analysis and Visualization.Main",
        "peekOfCode": "data = pd.read_csv(\"vehicle_data_1.csv\")\n#Step 1 : Shape or Dimensions of the DataFrame\nprint(\"DF Shape\")\n#Step 2 : Explore Data Types of the various columns\nprint(\"DF Column Types\")\n#Step 3 : Explore data by displaying 5 rows\nprint(\"Top 5 rows\")\n#Numerical Features Plots\n#create df of numeric features only.\nnum_cols = data.select_dtypes(exclude='object')",
        "detail": "Univariate Data Analysis and Visualization.Main",
        "documentation": {}
    },
    {
        "label": "num_cols",
        "kind": 5,
        "importPath": "Univariate Data Analysis and Visualization.Main",
        "description": "Univariate Data Analysis and Visualization.Main",
        "peekOfCode": "num_cols = data.select_dtypes(exclude='object')\n#Set size of figure \ncols = 3\nrows = 3\nfig = plt.figure(figsize=(cols*5, rows*5))\nplt.subplots_adjust(hspace=0.5, wspace=0.5)\n#Step 4 : Plot  Histogram for all numeric features (Use sns.histplot())\n#(Set title as \"Histogram\" .Save in file uahistogram.png)\nplt.suptitle(\"Histogram\")\nfor i, col in enumerate(num_cols):",
        "detail": "Univariate Data Analysis and Visualization.Main",
        "documentation": {}
    },
    {
        "label": "cols",
        "kind": 5,
        "importPath": "Univariate Data Analysis and Visualization.Main",
        "description": "Univariate Data Analysis and Visualization.Main",
        "peekOfCode": "cols = 3\nrows = 3\nfig = plt.figure(figsize=(cols*5, rows*5))\nplt.subplots_adjust(hspace=0.5, wspace=0.5)\n#Step 4 : Plot  Histogram for all numeric features (Use sns.histplot())\n#(Set title as \"Histogram\" .Save in file uahistogram.png)\nplt.suptitle(\"Histogram\")\nfor i, col in enumerate(num_cols):\n    ax=fig.add_subplot(rows,cols,i+1)\n    sns.histplot(x = data[col], ax = ax)",
        "detail": "Univariate Data Analysis and Visualization.Main",
        "documentation": {}
    },
    {
        "label": "rows",
        "kind": 5,
        "importPath": "Univariate Data Analysis and Visualization.Main",
        "description": "Univariate Data Analysis and Visualization.Main",
        "peekOfCode": "rows = 3\nfig = plt.figure(figsize=(cols*5, rows*5))\nplt.subplots_adjust(hspace=0.5, wspace=0.5)\n#Step 4 : Plot  Histogram for all numeric features (Use sns.histplot())\n#(Set title as \"Histogram\" .Save in file uahistogram.png)\nplt.suptitle(\"Histogram\")\nfor i, col in enumerate(num_cols):\n    ax=fig.add_subplot(rows,cols,i+1)\n    sns.histplot(x = data[col], ax = ax)\nplt.savefig(\"uahistogram.png\")",
        "detail": "Univariate Data Analysis and Visualization.Main",
        "documentation": {}
    },
    {
        "label": "fig",
        "kind": 5,
        "importPath": "Univariate Data Analysis and Visualization.Main",
        "description": "Univariate Data Analysis and Visualization.Main",
        "peekOfCode": "fig = plt.figure(figsize=(cols*5, rows*5))\nplt.subplots_adjust(hspace=0.5, wspace=0.5)\n#Step 4 : Plot  Histogram for all numeric features (Use sns.histplot())\n#(Set title as \"Histogram\" .Save in file uahistogram.png)\nplt.suptitle(\"Histogram\")\nfor i, col in enumerate(num_cols):\n    ax=fig.add_subplot(rows,cols,i+1)\n    sns.histplot(x = data[col], ax = ax)\nplt.savefig(\"uahistogram.png\")\nplt.clf()",
        "detail": "Univariate Data Analysis and Visualization.Main",
        "documentation": {}
    },
    {
        "label": "\tdf",
        "kind": 5,
        "importPath": "Univariate Data Analysis and Visualization.Main",
        "description": "Univariate Data Analysis and Visualization.Main",
        "peekOfCode": "\tdf = data[col].value_counts()\n\tax = fig.add_subplot(rows, cols, i+1)\n\tplt.pie(df, labels=df.index, autopct=\"%.0f%%\")\nplt.savefig(\"uapiechart.png\")\nplt.clf()",
        "detail": "Univariate Data Analysis and Visualization.Main",
        "documentation": {}
    },
    {
        "label": "\tax",
        "kind": 5,
        "importPath": "Univariate Data Analysis and Visualization.Main",
        "description": "Univariate Data Analysis and Visualization.Main",
        "peekOfCode": "\tax = fig.add_subplot(rows, cols, i+1)\n\tplt.pie(df, labels=df.index, autopct=\"%.0f%%\")\nplt.savefig(\"uapiechart.png\")\nplt.clf()",
        "detail": "Univariate Data Analysis and Visualization.Main",
        "documentation": {}
    }
]